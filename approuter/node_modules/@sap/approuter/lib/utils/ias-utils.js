'use strict';

const uaaUtils               = require('../utils/uaa-utils');
const urlUtils               = require('../utils/url-utils');
const _                      = require('lodash');
const request                = require('./request-utils');
const NodeCache              = require('node-cache');
const {getValidatedEnvInt}   = require('./env-utils');
const freshnessTTL           = getValidatedEnvInt('ZONE_INFO_CACHE_TTL', 600);
const maxCacheTTL            = getValidatedEnvInt('ZONE_INFO_MAX_CACHE_TTL', 14400); // 4 hours default
// Single cache with automatic cleanup for unused entries
const zoneInfoCache = new NodeCache({ stdTTL: maxCacheTTL, checkperiod: Math.max(600, Math.floor(maxCacheTTL / 24)) });

// Subdomain cache configuration
const subdomainCacheTTL      = getValidatedEnvInt('SUBDOMAIN_CACHE_TTL', 3600); // 1 hour default
const subdomainCache = new NodeCache({ stdTTL: subdomainCacheTTL, checkperiod: Math.max(600, Math.floor(subdomainCacheTTL / 12)) });

exports.getIasConfig          = getIasConfig;
exports.getIasCredentials     = getIasCredentials;
exports.getZoneInfo           = getZoneInfo;
exports.callZoneInfoAPI       = callZoneInfoAPI;
exports.ZoneInfoCache         = zoneInfoCache;
exports.getSubdomainByApptid  = getSubdomainByApptid;

function getIasConfig(req, cb) {
  let iasOptions = req.extIasConfigOptions || req.routerConfig.iasConfig.options;
  if (req.app && req.app.approuter && req.app.approuter.resolveIasConfig) {
    req.app.approuter.resolveIasConfig(req, iasOptions, cb);
  } else {
    resolveIasConfig(req, iasOptions, cb);
  }
}

function resolveIasConfig(req, iasOptions, cb) {
  iasOptions = _.clone(iasOptions);
  let requestHost = urlUtils.getAppRouterHost(req);
  let tenantHostPattern = req.routerConfig.iasConfig.tenantHostPattern;
  if (!tenantHostPattern){
    cb (null,iasOptions);
  } else {
    let tenant = uaaUtils.retrieveTenantFromURL (requestHost, tenantHostPattern);
    if (!req.zoneInfo){
      return cb('Missing zone information. Check IAS configuration and trust. See KBA 3479740.');
    }
    iasOptions.tenant = tenant;
    cb(null, iasOptions);
  }
}

function getIasCredentials(req){
  return req && req.routerConfig && req.routerConfig.iasConfig && req.routerConfig.iasConfig.options.url ? req.routerConfig.iasConfig.options : null;
}

function getZoneInfo(tenant, iasConfig, uaadomain, logger, cb) {
  logger = logger && logger.getLogger && logger.getLogger('/ias-utils.js');
  let zoneInfo = null;
  if (!tenant){
    zoneInfo = {
      authenticationType   : 'ias',
      status               : 'ACTIVE',
      apptid               : iasConfig.zone_uuid || iasConfig.app_tid,
      authorizationEndpoint: iasConfig.authorization_endpoint,
      tokenEndpoint        : iasConfig.url + '/oauth2/token',
      endSessionEndpoint   : iasConfig.end_session_endpoint,
      userInfoEndpoint     : iasConfig.url + '/oauth2/userinfo'
    };
    return cb(null, zoneInfo);
  }

  const cachedEntry = zoneInfoCache.get(tenant);
  const now = Date.now() / 1000; // Current time in seconds

  // If cache entry exists and is fresh, return it
  if (cachedEntry && cachedEntry.timestamp && (now - cachedEntry.timestamp) < freshnessTTL) {
    logger && logger.info('zoneInfo fetched from fresh cache');
    return cb(null, cachedEntry.data);
  }

  if (!uaadomain && !iasConfig['btp-tenant-api']){
    return cb(new Error('Can not get zone info by subdomain, xsuaa domain or  bt-tenant-api missing'));
  }

  let iasClientId = iasConfig.clientid;
  if (iasConfig.iasOnly) {
    // in case only IAS is bound, no need to send the client id from the IAS service
    iasClientId = null;
  }

  exports.callZoneInfoAPI(uaadomain, iasConfig['btp-tenant-api'], tenant, iasClientId, iasConfig.iasOnly || false, logger, (err, zoneInfo) => {
    if (err) {
      // If API fails and we have expired cached data, use it as fallback
      if (cachedEntry && cachedEntry.data) {
        logger && logger.info(`Using expired cached zoneInfo as fallback for tenant ${tenant}`);
        return cb(null, cachedEntry.data);
      } else {
        logger && logger.error('Failed to get zone info from IAS API: ' + err.message);
        return cb(err);
      }
    } else {
      // API success - store in cache with timestamp
      const cacheEntry = {
        data: zoneInfo,
        timestamp: Date.now() / 1000
      };
      zoneInfoCache.set(tenant, cacheEntry);
      return cb(null, zoneInfo);
    }
  });
}

function callZoneInfoAPI(uaadomain, btpTenantAPI, subdomain, iasClientId, iasOnly, logger, cb) {

  const validators = require('./../configuration/validators');

  // Build the base URL without query parameters
  const baseUrl = btpTenantAPI ? `${btpTenantAPI}/sap/rest/tenantLoginInfo/${subdomain}` : `https://api.${uaadomain}/sap/rest/tenantLoginInfo/${subdomain}`;

  // Add the iasClient query parameter only if iasClientId is not null
  const zoneInfoUrl = iasClientId !== null ? `${baseUrl}?iasClient=${iasClientId}` : baseUrl;

  request.get({url: zoneInfoUrl}, (err, res, body) => {
    if (err || res.statusCode !== 200) {
      return cb(new Error('Failed to call get Zone and IAS tenant ' + err + ' response status ' + res.statusCode));
    }
    try {
      const responseJSON = JSON.parse(body);
      let zoneInfo = {};
      if (responseJSON.status === 'ACTIVE' && (iasOnly || responseJSON.authentication === 'ias')) {
        validators.validateZoneInfo(responseJSON);

        zoneInfo = {
          authenticationType: iasOnly ? 'ias' : responseJSON.authentication,
          status: responseJSON.status,
          apptid: responseJSON.zoneId || responseJSON.app_tid,
          authorizationEndpoint: responseJSON.authorization_endpoint,
          tokenEndpoint: responseJSON.token_endpoint,
          userInfoEndpoint: responseJSON.userinfo_endpoint,
          endSessionEndpoint: responseJSON.end_session_endpoint,
          oidcMetadata: responseJSON.oidc_metadata
        };
        logger && logger.info('zoneInfo fetched from xsuaa');
      } else {
        logger && logger.info(`IAS is not trusted for subdomain ${subdomain}. Please check Saas Registry/SMS subscriptions`);
      }
      cb(null, zoneInfo);
    } catch (err) {
      return cb(new Error('Failed to parse get Zone and IAS tenant response ' + (err.message ? err.message : err)));
    }
  });
}

async function getSubdomainByApptid(apptid, btpTenantAPI) {
  // Check cache first
  const cachedSubdomain = subdomainCache.get(apptid);
  if (cachedSubdomain !== undefined) {
    return cachedSubdomain;
  }

  // Fetch from API if not in cache
  const baseUrl = `${btpTenantAPI}/sap/rest/tenantLoginInfo/?id=${apptid}`;
  let result = await request.axiosRequest('get',{url: baseUrl});
  if (result.error || result.response.statusCode !== 200){
    throw new Error('Failed to fetch subdomain for app_tid ' + apptid);
  }
  const resultBody = result.body && JSON.parse(result.body);
  if (resultBody && resultBody.subdomain) {
    // Store in cache
    subdomainCache.set(apptid, resultBody.subdomain);
    return resultBody.subdomain;
  }
  throw new Error('Failed to fetch subdomain for app_tid ' + apptid);
}
